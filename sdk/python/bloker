import logging

version = "2.1.1"

user_agent = "Broker-P V" + version

broker_log = logging.getLogger("broker-client")

import hashlib
import hmac
import re
import time
import urllib

import requests
import six
from requests.adapters import HTTPAdapter

from broker.exceptions import BrokerApiException, BrokerRequestException
from broker import user_agent, broker_log


class Request(object):

    API_VERSION = 'v1'
    QUOTE_API_VERSION = 'v1'

    _session = None

    def __init__(self, entry_point, api_key='', secret='', proxies=None):

        if not entry_point.endswith('/'):
            entry_point = entry_point + '/'
        self.api_key = api_key
        self.secret = secret
        self.entry_point = entry_point
        self.proxies = proxies
        self.ping()

    @classmethod
    def init_connection_args(cls, pool_connections=16, pool_maxsize=16, max_retries=3, pool_block=False):
        http_adapter = HTTPAdapter(pool_connections, pool_maxsize, max_retries, pool_block)
        cls._session = requests.Session()
        cls._session.mount('https://', http_adapter)
        cls._session.mount('http://', http_adapter)

    def _create_api_uri(self, path, version):
        version_path = ''
        if version:
            version_path = version + '/'
        return self.entry_point + version_path + path

    def _create_quote_api_uri(self, path, version):
        return self.entry_point + 'quote/' + version + '/' + path

    def _generate_signature(self, data):

        if six.PY2:
            params_str = urllib.urlencode(data)
        else:
            params_str = urllib.parse.urlencode(data)

        digest = hmac.new(self.secret.encode(encoding='UTF8'),
                          params_str.encode(encoding='UTF8'),
                          digestmod=hashlib.sha256).hexdigest()
        return digest

    def _get(self, path, signed=False, version=API_VERSION, **kwargs):
        uri = self._create_api_uri(path, version)
        return self._request('GET', uri, signed, **kwargs)

    def _post(self, path, signed=False, version=API_VERSION, **kwargs):
        uri = self._create_api_uri(path, version)
        return self._request('POST', uri, signed, **kwargs)

    def _put(self, path, signed=False, version=API_VERSION, **kwargs):
        uri = self._create_api_uri(path, version)
        return self._request('PUT', uri, signed, **kwargs)

    def _delete(self, path, signed=False, version=API_VERSION, **kwargs):
        uri = self._create_api_uri(path, version)
        return self._request('DELETE', uri, signed, **kwargs)

    def _quote_get(self, path, signed=False, version=QUOTE_API_VERSION, **kwargs):
        uri = self._create_quote_api_uri(path, version)
        return self._request('GET', uri, signed, **kwargs)

    def _request(self, method, uri, signed, **kwargs):

        if 'timeout' not in kwargs:
            kwargs['timeout'] = 10

        date_type = 'data' if method == 'POST' else 'params'
        if date_type not in kwargs:
            kwargs[date_type] = {}

        kwargs[date_type]['timestamp'] = int(time.time() * 1000)

        self._process_parameters(kwargs[date_type])

        if signed:
            kwargs[date_type]['signature'] = self._generate_signature(kwargs[date_type])

        kwargs['headers'] = {
            'X-BH-APIKEY': self.api_key,
            'User-Agent': user_agent
        }

        broker_log.debug("Request method: [{}] url: [{}] headers: [{}] params: [{}]".format(
            method, uri, kwargs['headers'], kwargs[date_type]))

        begin_time = time.time()
        if self._session is None:
            response = requests.request(method, uri, proxies=self.proxies, **kwargs)
        else:
            response = self._session.request(method, uri, proxies=self.proxies, **kwargs)
        end_time = time.time()

        req_time = int((begin_time-end_time)*1000)
        broker_log.debug("Response code: [{}] message: [{}] body: [{}] reqTime: [{}ms]".format(
            method, uri, response.text, req_time))

        return self._handle_response(response)

    @classmethod
    def _process_parameters(cls, parameters):
        assert isinstance(parameters, dict)

        processed_parameters = dict()
        for name, value in parameters.items():
            processed_parameters[cls._camelcase(name)] = '' if value is None else value
        parameters.clear()
        parameters.update(processed_parameters)

    @classmethod
    def _camelcase(cls, name):
        name = re.sub(r"^[\-_.]", '', str(name))
        if not name:
            return name
        return name[0].lower() + re.sub(r"[\-_.\s]([a-z])", lambda matched: matched.group(1).upper(), name[1:])

    @classmethod
    def _handle_response(cls, response):

        if not str(response.status_code).startswith('2') and not response.status_code == 400:
            raise BrokerApiException(response)
        try:
            return response.json()
        except ValueError:
            raise BrokerRequestException('Invalid Response: %s' % response.text)

    def ping(self):
        return self._get('ping')

    def time(self):
        """
        Check server time
        """
        return self._get('time')

    def broker_info(self, trade_type=''):
        """
        Broker information
        """
        params = {
            'type': trade_type
        }
        return self._get('brokerInfo', params=params)

    def stream_get_listen_key(self):
        """
        Start user data stream (USER_STREAM)
        """
        return self._post('userDataStream', signed=True)

    def stream_keepalive(self, listen_key):
        """
        Keepalive user data stream (USER_STREAM)
        """
        params = {
            'listenKey': listen_key
        }
        return self._put('userDataStream', signed=True, params=params)

    def stream_close(self, listen_key):
        """
        Close user data stream (USER_STREAM)
        """
        params = {
            'listenKey': listen_key
        }
        return self._delete('userDataStream', signed=True, params=params)

from broker.base import Request


class BrokerClient(Request):

    def depth(self, symbol, limit=100):
        """
        Market Data endpoints
        """
        params = {
            'symbol': symbol,
            'limit': limit,
        }
        return self._quote_get('depth', params=params)

    def trades(self, symbol, limit=100):
        """
        Recent trades list
        """
        params = {
            'symbol': symbol,
            'limit': limit,
        }
        return self._quote_get('trades', params=params)

    def klines(self, symbol, interval='1m', start_time='', end_time='', limit=100):
        """
        Kline/Candlestick data
        """
        params = {
            'symbol': symbol,
            'interval': interval,
            'startTime': start_time,
            'endTime': end_time,
            'limit': limit,
        }
        return self._quote_get('klines', params=params)

    def ticker_24hr(self, symbol=''):
        """
        24hr ticker price change statistics
        """
        params = {
            'symbol': symbol,
        }
        return self._quote_get('ticker/24hr', params=params)

    def ticker_price(self, symbol=''):
        """
        Symbol price ticker
        """
        params = {
            'symbol': symbol,
        }
        return self._quote_get('ticker/price', params=params)

    def book_ticker(self, symbol=''):
        """
        Symbol order book ticker
        """
        params = {
            'symbol': symbol,
        }
        return self._quote_get('ticker/bookTicker', params=params)

    def order_new(self, **params):
        """
        New order  (TRADE)
        """
        return self._post('order', signed=True, data=params)

    def order_test(self, **params):
        """
        Test new order (TRADE)
        """
        return self._post('order/test', signed=True, data=params)

    def order_get(self, order_id='', orig_client_order_id=''):
        """
        Query order (USER_DATA)
        """
        params = {
            'orderId': order_id,
            'origClientOrderId': orig_client_order_id
        }
        return self._get('order', signed=True, params=params)

    def order_cancel(self, order_id='', client_order_id=''):
        """
        Cancel order (TRADE)
        """
        params = {
            'orderId': order_id,
            'clientOrderId': client_order_id
        }
        return self._delete('order', signed=True, params=params)

    def open_orders(self, **params):
        """
        Current open orders (USER_DATA)
        """
        return self._get('openOrders', signed=True, params=params)

    def history_orders(self, **params):
        """
        History open orders (USER_DATA)
        """
        return self._get('historyOrders', signed=True, params=params)

    def account(self):
        """
        Account information (USER_DATA)
        """
        return self._get('account', signed=True)

    def my_trades(self, **params):
        """
        Account trade list (USER_DATA)
        """
        return self._get('myTrades', signed=True, params=params)

    def deposit_orders(self, **params):
        """
        GET deposit orders for a specific account.
        """
        return self._get('depositOrders', signed=True, params=params)


class BrokerOptionClient(Request):

    def index(self):
        """
        Get underlying index and EDP
        :return:
        """
        return self._quote_get('option/index')

    def klines(self, symbol, interval='1m', start_time='', end_time='', limit=100):
        """
        Kline/Candlestick data
        """
        params = {
            'symbol': symbol,
            'interval': interval,
            'startTime': start_time,
            'endTime': end_time,
            'limit': limit,
        }
        return self._quote_get('option/klines', params=params)

    def depth(self, symbol, limit=100):
        """
        Market Data endpoints
        """
        params = {
            'symbol': symbol,
            'limit': limit,
        }
        return self._quote_get('option/depth', params=params)

    def trades(self, symbol, limit=100):
        """
        Recent trades list
        """
        params = {
            'symbol': symbol,
            'limit': limit,
        }
        return self._quote_get('option/trades', params=params)

    def order_new(self, **params):
        """
        New order  (TRADE)
        """
        return self._post('option/order', signed=True, data=params, version=None)

    def order_get(self, order_id='', orig_client_order_id=''):
        """
        Query order (USER_DATA)
        """
        params = {
            'orderId': order_id,
            'origClientOrderId': orig_client_order_id
        }
        return self._get('getOptions', signed=True, params=params)

    def order_cancel(self, order_id='', client_order_id=''):
        """
        Cancel order (TRADE)
        """
        params = {
            'orderId': order_id,
            'clientOrderId': client_order_id
        }
        return self._delete('option/order/cancel', signed=True, params=params, version=None)

    def open_orders(self, **params):
        """
        Current open orders (USER_DATA)
        """
        return self._get('option/openOrders', signed=True, params=params, version=None)

    def history_orders(self, **params):
        """
        History open orders (USER_DATA)
        """
        return self._get('option/historyOrders', signed=True, params=params, version=None)

    def option_account(self):
        """
        Account information (USER_DATA)
        """
        return self._get('option/account', signed=True, version=None)

    def my_trades(self, **params):
        """
        Account trade list (USER_DATA)
        """
        return self._get('option/myTrades', signed=True, params=params, version=None)

    def positions(self, **params):
        """
        Get current positions
        """
        return self._get('option/positions', signed=True, params=params, version=None)

    def settlements(self, **params):
        """
        Get settlement history
        """
        return self._get('option/settlements', signed=True, params=params, version=None)

    def get_order(self, order_id='', client_order_id=''):
        params = {
            'orderId': order_id,
            'clientOrderId': client_order_id,
        }
        return self._get('option/getOrder', signed=True, params=params, version=None)


class BrokerContractClient(Request):

    def order_new(self, **params):
        """
        Create new contract order
        """
        return self._post('contract/order', signed=True, data=params, version=None)

    def order_new_test(self, **params):
        """
        Test create new contract order
        """
        return self._post('contract/order/test', signed=True, data=params, version=None)

    def order_cancel(self, order_id='', client_order_id='', order_type='LIMIT'):
        """
        Cancel contract order
        """
        params = {
            'orderId': order_id,
            'clientOrderId': client_order_id,
            'orderType': order_type
        }
        return self._delete('contract/order/cancel', signed=True, params=params, version=None)

    def order_batch_cancel(self, symbols):
        """
        Batch cancel contract order
        """
        params = {
            'symbol': isinstance(symbols, (list, tuple)) and ','.join(symbols) or symbols,
        }
        return self._delete('contract/order/batchCancel', signed=True, params=params, version=None)

    def get_order(self, order_type, order_id='', client_order_id=''):
        params = {
            'orderType': order_type,
            'orderId': order_id,
            'clientOrderId': client_order_id,
        }
        return self._get('contract/getOrder', signed=True, params=params, version=None)

    def open_orders(self, symbol='', order_id='', order_side='', order_type='', limit=20):
        """
        Get open contract orders
        """
        params = {
            'symbol': symbol,
            'orderId': order_id,
            'side': order_side,
            'orderType': order_type,
            'limit': limit
        }
        return self._get('contract/openOrders', signed=True, params=params, version=None)

    def history_orders(self, symbol='', order_id='', order_side='', order_type='', limit=20):
        """
        Query history contract orders
        """
        params = {
            'symbol': symbol,
            'orderId': order_id,
            'side': order_side,
            'orderType': order_type,
            'limit': limit
        }
        return self._get('contract/historyOrders', signed=True, params=params, version=None)

    def my_trades(self, symbol='', order_side='', from_id='', to_id='', limit=20):
        """
        Query contract trades
        """
        params = {
            'symbol': symbol,
            'side': order_side,
            'fromId': from_id,
            'toId': to_id,
            'limit': limit
        }
        return self._get('contract/myTrades', signed=True, params=params, version=None)

    def get_positions(self, symbol='', order_side=''):
        """
        Get contract positions
        """
        params = {
            'symbol': symbol,
            'side': order_side
        }
        return self._get('contract/positions', signed=True, params=params, version=None)

    def get_settlements(self, symbol=''):
        """
        Get contract settlements
        """
        params = {
            'symbol': symbol
        }
        return self._get('contract/settlements', signed=True, params=params, version=None)

    def account(self):
        """
        Get contract account info
        """
        return self._get('contract/account', signed=True, version=None)

    def modify_margin(self, symbol, order_side, amount):
        """
        modify contract margin
        """
        params = {
            'symbol': symbol,
            'side': order_side,
            'amount': amount
        }
        return self._post('contract/modifyMargin', signed=True, data=params, version=None)

    def get_contracts(self):
        """
        Get contract info
        """
        return self._get('getContracts', version=None)

    def get_insurances(self, symbol='', from_id='', to_id='', limit=20):
        """
        Get contract insurance fund
        """
        params = {
            'symbol': symbol,
            'fromId': from_id,
            'toId': to_id,
            'limit': limit
        }
        return self._get('brokerInfo', params=params, version=None)

    def get_funding_rates(self, symbol='', state='current'):
        """
        Get contract funding rates
        """
        params = {
            'symbol': symbol,
            'state': state,
        }
        return self._get('contract/fundingRate', params=params, version=None)

    def index(self, symbol=''):
        """
        Get underlying index and EDP
        :return:
        """
        params = {
            'symbol': symbol
        }
        return self._quote_get('contract/index', params=params)

    def klines(self, symbol, interval='1m', start_time='', end_time='', limit=100):
        """
        Kline/Candlestick data
        """
        params = {
            'symbol': symbol,
            'interval': interval,
            'startTime': start_time,
            'endTime': end_time,
            'limit': limit,
        }
        return self._quote_get('contract/klines', params=params)

    def depth(self, symbol, limit=100):
        """
        Market Data endpoints
        """
        params = {
            'symbol': symbol,
            'limit': limit,
        }
        return self._quote_get('contract/depth', params=params)

    def trades(self, symbol, limit=100):
        """
        Recent trades list
        """
        params = {
            'symbol': symbol,
            'limit': limit,
        }
        return self._quote_get('contract/trades', params=params)

# coding=utf-8


class BrokerApiException(Exception):

    def __init__(self, response):
        self.code = 0
        try:
            json_res = response.json()
        except ValueError:
            self.message = 'Invalid JSON error message from Broker: {} http code: {}'.format(
                response.text, response.status_code)
        else:
            self.code = json_res['code']
            self.message = json_res['msg']
        self.status_code = response.status_code
        self.response = response
        self.request = getattr(response, 'request', None)

    def __str__(self):
        return 'APIError(code=%s): %s' % (self.code, self.message)


class BrokerRequestException(Exception):

    def __init__(self, message):
        self.message = message

    def __str__(self):
        return 'BrokerRequestException: %s' % self.message

import json
import threading

from autobahn.twisted.websocket import WebSocketClientFactory, WebSocketClientProtocol, connectWS
from twisted.internet import reactor, ssl
from twisted.internet.error import ReactorAlreadyRunning
from twisted.internet.protocol import ReconnectingClientFactory

from broker import user_agent
from broker.exceptions import BrokerRequestException
from broker.client import BrokerClient


class BrokerClientProtocol(WebSocketClientProtocol):

    def __init__(self, factory, payload=None):
        super(BrokerClientProtocol, self).__init__()
        self.factory = factory
        self.payload = payload

    def onOpen(self):
        self.factory.protocol_instance = self

    def onConnect(self, response):
        if self.payload:
            self.sendMessage(self.payload, isBinary=False)
        self.factory.resetDelay()

    def onMessage(self, payload, isBinary):
        if not isBinary:
            try:
                payload_obj = json.loads(payload.decode('utf8'))
            except ValueError:
                pass
            else:
                self.factory.callback(payload_obj)


class BrokerReconnectingClientFactory(ReconnectingClientFactory):

    # set initial delay to a short time
    initialDelay = 0.1

    maxDelay = 10

    maxRetries = 5


class BrokerClientFactory(WebSocketClientFactory, BrokerReconnectingClientFactory):

    def __init__(self, *args, **kwargs):
        self.payload = kwargs.pop('payload')
        WebSocketClientFactory.__init__(self, *args, **kwargs)
        self.protocol_instance = None
        self.base_client = None

    protocol = BrokerClientProtocol
    _reconnect_error_payload = {
        'e': 'error',
        'm': 'Max reconnect retries reached'
    }

    def clientConnectionFailed(self, connector, reason):
        self.retry(connector)
        if self.retries > self.maxRetries:
            self.callback(self._reconnect_error_payload)

    def clientConnectionLost(self, connector, unused_reason):
        self.retry(connector)
        if self.retries > self.maxRetries:
            self.callback(self._reconnect_error_payload)

    def buildProtocol(self, addr):
        return BrokerClientProtocol(self, payload=self.payload)


class BrokerSocketManager(threading.Thread):

    def __init__(self, entry_point, rest_entry_point, api_key='', secret='', auth=True):
        threading.Thread.__init__(self)
        self.factories = {}
        self._conns = {}
        self._connected_event = threading.Event()
        self._api_key = api_key
        self._secret = secret
        self._user_timer = None
        self._listen_key = None

        if auth:
            self._client = BrokerClient(rest_entry_point, api_key=self._api_key, secret=self._secret) if api_key and secret else None

        if not entry_point.endswith('/'):
            entry_point = entry_point + '/'
        self._entry_point = entry_point

    def _start_socket(self, id_, path, payload, callback):
        if id_ in self._conns:
            return False

        factory_url = self._entry_point + path
        factory = BrokerClientFactory(factory_url, useragent=user_agent, payload=payload)
        factory.base_client = self
        factory.protocol = BrokerClientProtocol
        factory.callback = callback
        factory.reconnect = True
        self.factories[id_] = factory
        reactor.callFromThread(self.add_connection, id_)

    def _start_quote_socket(self, id_, payload, callback):
        self._start_socket(id_, 'quote/ws/v1', payload, callback)

    def _start_quote_socket_v2(self, id_, payload, callback):
        self._start_socket(id_, 'quote/ws/v2', payload, callback)

    def _start_auth_socket(self, id_, payload, callback):
        listen_key = self._client.stream_get_listen_key()
        if not listen_key:
            raise BrokerRequestException('Get listen key failure.')
        self._listen_key = listen_key.get('listenKey', '')
        path = 'ws/' + self._listen_key
        self._start_socket(id_, path, payload, callback)
        self._start_user_timer()

    def add_connection(self, id_):
        factory = self.factories[id_]
        context_factory = ssl.ClientContextFactory()
        self._conns[id_] = connectWS(factory, context_factory)

    def _start_user_timer(self):
        self._user_timer = threading.Timer(1800, self._keep_alive_user_socket)
        self._user_timer.setDaemon(True)
        self._user_timer.start()

    def _keep_alive_user_socket(self):
        self._client.stream_keepalive(self._listen_key)
        self._start_user_timer()

    def stop_socket(self, conn_key):
        if conn_key not in self._conns:
            return

        self._conns[conn_key].factory = WebSocketClientFactory(self._entry_point)
        self._conns[conn_key].disconnect()
        del self._conns[conn_key]

    def run(self):
        try:
            reactor.run(installSignalHandlers=False)
        except ReactorAlreadyRunning:
            # Ignore error about reactor already runing
            pass

    def close(self):
        keys = set(self._conns.keys())
        for key in keys:
            self.stop_socket(key)

        reactor.callFromThread(reactor.stop)
        self._conns = {}


class BrokerWss(BrokerSocketManager):

    def subscribe_to_realtimes(self, symbol, callback):
        id_ = "_".join(["realtimes", symbol])
        data = {
            'event': 'sub',
            'topic': 'realtimes',
            'symbol': symbol,
        }
        payload = json.dumps(data, ensure_ascii=False).encode('utf8')
        return self._start_quote_socket(id_, payload, callback)

    def subscribe_to_trades(self, symbol, callback):
        id_ = "_".join(["trades", symbol])
        data = {
            'event': 'sub',
            'topic': 'trade',
            'symbol': symbol,
        }
        payload = json.dumps(data, ensure_ascii=False).encode('utf8')
        return self._start_quote_socket(id_, payload, callback)

    def subscribe_to_kline(self, symbol, interval, callback):
        id_ = "_".join(["kline", symbol, interval])
        data = {
            'event': 'sub',
            'topic': 'kline_' + interval,
            'symbol': symbol,
        }
        payload = json.dumps(data, ensure_ascii=False).encode('utf8')
        return self._start_quote_socket(id_, payload, callback)

    def subscribe_to_depth(self, symbol, callback):
        id_ = "_".join(["depth", symbol])
        data = {
            'event': 'sub',
            'topic': 'depth',
            'symbol': symbol,
        }
        payload = json.dumps(data, ensure_ascii=False).encode('utf8')
        return self._start_quote_socket(id_, payload, callback)

    def subscribe_to_index(self, symbol, callback):
        id_ = "_".join(["index", symbol])
        data = {
            'event': 'sub',
            'topic': 'index',
            'symbol': symbol,
        }
        payload = json.dumps(data, ensure_ascii=False).encode('utf8')
        return self._start_quote_socket(id_, payload, callback)

    def user_data_stream(self, callback):
        return self._start_auth_socket('user_data_stream', None, callback)


class BrokerWssV2(BrokerWss):

    def subscribe_to_realtimes(self, symbol, callback):
        id_ = "_".join(["realtimes", symbol])
        data = {
            'topic': 'realtimes',
            'event': "sub",
            'params': {
                'binary': False,
                'symbol': symbol
            }
        }
        payload = json.dumps(data, ensure_ascii=False).encode('utf8')
        return self._start_quote_socket_v2(id_, payload, callback)

    def subscribe_to_trades(self, symbol, callback):
        id_ = "_".join(["trade", symbol])
        data = {
            'topic': 'trade',
            'event': "sub",
            'params': {
                'binary': False,
                'symbol': symbol
            }
        }
        payload = json.dumps(data, ensure_ascii=False).encode('utf8')
        return self._start_quote_socket_v2(id_, payload, callback)

    def subscribe_to_kline(self, symbol, interval, callback):
        id_ = "_".join(["kline", symbol, interval])
        data = {
            'topic': 'kline',
            'event': "sub",
            'params': {
                'binary': False,
                'symbol': symbol,
                'klineType': interval
            }
        }
        payload = json.dumps(data, ensure_ascii=False).encode('utf8')
        return self._start_quote_socket_v2(id_, payload, callback)

    def subscribe_to_depth(self, symbol, callback):
        id_ = "_".join(["depth", symbol])
        data = {
            'topic': 'depth',
            'event': "sub",
            'params': {
                'binary': False,
                'symbol': symbol
            }
        }
        payload = json.dumps(data, ensure_ascii=False).encode('utf8')
        return self._start_quote_socket_v2(id_, payload, callback)

    def subscribe_to_book_ticker(self, symbol, callback):
        id_ = "_".join(["bookTicker", symbol])
        data = {
            'topic': 'bookTicker',
            'event': "sub",
            'params': {
                'binary': False,
                'symbol': symbol
            }
        }
        payload = json.dumps(data, ensure_ascii=False).encode('utf8')
        return self._start_quote_socket_v2(id_, payload, callback)
